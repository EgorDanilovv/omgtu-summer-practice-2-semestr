#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №9. Реализация длительных операций.

**Цель:** Предоставить возможность выполннеия команд, для полного завершения которых требуется более одного вызова Execute.

**Результаты:** После выполнения работы Вы сможете:
1. Выполнять длительные опреации в отдельном потоке без монопольного использования потока в течение длительного времени.
3. Прерывать выполнение таких команд. 


## Задание.
Если для полного выполнения командв потребуется более одного вызова Execute, необходимо такую команду добавить в планировщик.

Для иллюстрации выполнненой работы определить команду

#!csharp

using System;
using System.Collections.Concurrent;
using System.Threading;

public interface ICommand
{
    void Execute();
}

// Измененная команда TestCommand, которая выполняется 3 раза
public class TestCommand : ICommand
{
    private int _executionCount = 0;
    private int _id;

    public TestCommand(int id)
    {
        _id = id;
    }

    public void Execute()
    {
        Console.WriteLine($"Поток {_id} вызов {_executionCount + 1}");
        _executionCount++;

        // Проверяем, не выполнили ли мы команду 3 раза
        if (_executionCount < 3)
        {
            // Если нет, возвращаем команду в планировщик
        }
        else
        {
            Console.WriteLine($"Поток {_id} завершил выполнение.");
        }
    }
}

public interface IScheduler
{
    bool HasCommand();
    ICommand Select();
    void Add(ICommand cmd);
}

// Планировщик Round-Robin
public class RoundRobinScheduler : IScheduler
{
    private readonly Queue<ICommand> scheduledCommands = new Queue<ICommand>();

    public bool HasCommand() => scheduledCommands.Count > 0;

    public ICommand Select()
    {
        if (scheduledCommands.Count == 0) throw new InvalidOperationException("Нет доступных комманд.");

        var cmd = scheduledCommands.Dequeue();
        scheduledCommands.Enqueue(cmd);
        return cmd;
    }

    public void Add(ICommand cmd) => scheduledCommands.Enqueue(cmd);
}

// Класс ServerThread для управления потоком и обработки команд
public class ServerThread
{
    private Thread thread;
    private ConcurrentQueue<ICommand> commandQueue;
    private volatile bool isRunning;
    private volatile bool softStopRequested;
    private IScheduler scheduler;

    public ServerThread(IScheduler scheduler)
    {
        commandQueue = new ConcurrentQueue<ICommand>();
        this.scheduler = scheduler;
        thread = new Thread(Run) { IsBackground = true };
        isRunning = true;
    }

    public void Start() { thread.Start(); }

    public void Stop() { isRunning = false; thread.Join(); }

    public void EnqueueCommand(ICommand command)
    {
        if (isRunning) { commandQueue.Enqueue(command); }
    }

    private void Run()
    {
        while (isRunning)
        {
            // Добавление новых команд в планировщик
            if (commandQueue.TryDequeue(out ICommand command))
            {
                scheduler.Add(command);
            }

            // Выполнение команд из планировщика в режиме Round Robin
            if (scheduler.HasCommand())
            {
                try
                {
                    var nextCommand = scheduler.Select();
                    nextCommand.Execute();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Исключение: {ex.Message}");
                }
            }
            else
            {
                Thread.Sleep(10); // предотвращает пустую трату процессорного времени
            }

            if (softStopRequested && commandQueue.IsEmpty && !scheduler.HasCommand())
            {
                isRunning = false;
            }
        }
    }

    public void RequestSoftStop() { softStopRequested = true; }

    public void HardStop() { isRunning = false; }

    public bool IsRunning => isRunning;

    public Thread GetThread() => thread;
}

// Команда HardStop для немедленной остановки потока
public class HardStopCommand : ICommand
{
    private readonly ServerThread serverThread;

    public HardStopCommand(ServerThread serverThread)
    {
        this.serverThread = serverThread;
    }

    public void Execute()
    {
        if (Thread.CurrentThread == serverThread.GetThread())
        {
            serverThread.HardStop();
        }
        else
        {
            throw new InvalidOperationException("HardStopCommand может выполняться только в потоке сервера.");
        }
    }
}

// Команда SoftStop для мягкой остановки потока
public class SoftStopCommand : ICommand
{
    private readonly ServerThread serverThread;

    public SoftStopCommand(ServerThread serverThread)
    {
        this.serverThread = serverThread;
    }

    public void Execute()
    {
        if (Thread.CurrentThread == serverThread.GetThread())
        {
            serverThread.RequestSoftStop();
        }
        else
        {
            throw new InvalidOperationException("SoftStopCommand может выполняться только в потоке сервера.");
        }
    }
}


        // Создаем планировщик
        IScheduler scheduler = new RoundRobinScheduler();

        // Создаем поток сервера
        ServerThread serverThread = new ServerThread(scheduler);

        // Запускаем поток сервера
        serverThread.Start();

        // Добавляем несколько команд в очередь
        for (int i = 1; i <= 5; i++)
        {
            serverThread.EnqueueCommand(new TestCommand(i));
        }

        // Ждем, пока команды завершатся
        Thread.Sleep(1000); // 10 секунд

        // Останавливаем поток с помощью HardStop
        serverThread.EnqueueCommand(new HardStopCommand(serverThread));

        // Ждем, пока HardStop не остановит поток
        Thread.Sleep(1000);

        // Ожидание завершения потока, чтобы программа не завершилась раньше времени
        serverThread.Stop();

        Console.WriteLine("Планировщик остановлен.");
        Console.ReadLine();

#!markdown

Необходимо проиллюстрировать выполнение 5 экземпляров TestCommand 3 раза, затем остановить поток с помощью HardStop.
