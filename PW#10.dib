#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №10. Доставка сообщений до Команды.

**Цель:** Предоставить возможность обмена данными для длительных операций.

**Результаты:** После выполнения работы Вы сможете:
1. Отправлять сообщения длительной операции.

## Задание.
Поскольку длительная операция выполняется в течение некоторого момента времени, то может возникнуть необходимость
в предоставлении дополнительной информации, влияющей на ход выполнения. Поскольку Команды и источник данных часто находятся в разных потоках,
то сделать это надо потоко-безопасным образом. Самый простой способ - используя идиому Производитель-Поребитель, в нашем случае - очередь.

Набор данных, предназначенных для Команды будем называть сообщением. Можно использовать любую подходящую конструкцию языка программирования для 
представления сообщения. Необходимо учесть, что скорость доставки сообщений может быть выше, чем скорость обработки, а значит очередь сообщений должна быть
у каждой Длительной операции. При этом потоко-безопасные очереди требуют системных ресурсов, а значит, чтобы не получить ограничение на максимальное количество
одновремнно работающих длительных Команд, нельзя использовать потоко-безопасные очереди. 

Возможный вариант реализации - оставить одну потоко-безопасную очередь для потока, а для Команд использовать обычные очереди. Осталось только решить, как сообщение
излеченное из очереди потока попадет в очередь Команды. Один из возможных вариантов:
1. Каждая команда имеет уникальный идентификатор.
2. Сообщение содержит уникальный идентификатор Команлды, которому оно адресовано.
3. Для потока создаем специальную Длительную Команду, которая назвается Роутером. Он хранит коллекцию пар (id Команды, ссылка на очередь Команды). При вызове метода Execute этой 
Роутера, если очередь потока не пуста, происходит чтение очередного сообщения и по id Команды определяется очередь, куда это сообщение записывается.
Если id Команды не определен, на консоль выводится сообщение о невозможности доставить сообщение неизвестному адресату.
При старте новой Команды, ее очередь необходимо добавить в коллекцию Роутера. При остановке Команды - очередь удаляется из коллекции Роутера.

Продемонстрировать работу Роутера на двух Длительных Командах и на отправке сообщения несуществующей Команде.

**Материалы для самостоятельного изучения**.
1. [Паттерн Сообщение](https://www.enterpriseintegrationpatterns.com/patterns/messaging/Message.html)
2. [Паттерн Роутер - весь раздел про Роутеры](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageRoutingIntro.html)
3. [Обмен сообщеними](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageConstructionIntro.html)

#!csharp

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading;

// Интерфейс для команд, которые будут выполняться в потоке сервера
public interface ICommand
{
    void Execute();
}

// Интерфейс для планировщика, который управляет очередью команд
public interface IScheduler
{
    bool HasCommand();
    ICommand Select();
    void Add(ICommand cmd);
}

// Интерфейс для обработчиков сообщений, которые обрабатывают сообщения от роутера
public interface IMessageHandler
{
    void HandleMessage(Message message);
}

// Планировщик типа Round-Robin, который выбирает команды по очереди
public class RoundRobinScheduler : IScheduler
{
    private readonly Queue<ICommand> scheduledCommands = new Queue<ICommand>();

    public bool HasCommand() => scheduledCommands.Count > 0;

    public ICommand Select()
    {
        if (scheduledCommands.Count == 0) throw new InvalidOperationException("Нет доступных команд.");

        var cmd = scheduledCommands.Dequeue();
        scheduledCommands.Enqueue(cmd);
        return cmd;
    }

    public void Add(ICommand cmd) => scheduledCommands.Enqueue(cmd);
}

// Класс для представления сообщения, которое будет передаваться в роутер
public class Message
{
    public int CommandId { get; }
    public string Data { get; }

    public Message(int commandId, string data)
    {
        CommandId = commandId;
        Data = data;
    }
}

// Базовый класс для длительных команд, которые могут обрабатывать сообщения
public class LongRunningCommand : ICommand, IMessageHandler
{
    private int commandId;
    private Queue<Message> messageQueue = new Queue<Message>();

    public LongRunningCommand(int commandId)
    {
        this.commandId = commandId;
    }

    public void Execute()
    {
        while (messageQueue.Count > 0)
        {
            var message = messageQueue.Dequeue();
            Thread.Sleep(100);
        }
    }

    public void HandleMessage(Message message)
    {
        Console.WriteLine($"Команда {commandId} получила сообщение: {message.Data}");
        messageQueue.Enqueue(message);
    }

    public int CommandId => commandId;
}

// Класс для маршрутизации сообщений к соответствующим обработчикам
public class MessageRouter : ICommand
{
    private ConcurrentQueue<Message> messageQueue = new ConcurrentQueue<Message>();
    private Dictionary<int, IMessageHandler> handlers = new Dictionary<int, IMessageHandler>();

    // Добавление обработчика сообщений для определенного ID команды
    public void AddHandler(int commandId, IMessageHandler handler) => handlers[commandId] = handler;

    // Удаление обработчика сообщений для определенного ID команды
    public void RemoveHandler(int commandId) => handlers.Remove(commandId);

    // Добавление сообщения в очередь
    public void EnqueueMessage(Message message) => messageQueue.Enqueue(message);

    // Обработка сообщений из очереди
    public void Execute()
    {
        while (messageQueue.TryDequeue(out var message))
        {
            if (handlers.TryGetValue(message.CommandId, out var handler))
            {
                handler.HandleMessage(message);
            }
            else
            {
                Console.WriteLine($"Неизвестный ID команды: {message.CommandId}");
            }
        }
    }
}

// Команда для выполнения жесткого завершения работы потока сервера
public class HardStopCommand : ICommand
{
    private readonly ServerThread serverThread;

    public HardStopCommand(ServerThread serverThread)
    {
        this.serverThread = serverThread;
    }

    public void Execute()
    {
        if (Thread.CurrentThread == serverThread.GetThread())
        {
            serverThread.HardStop();
        }
        else
        {
            throw new InvalidOperationException("HardStopCommand может выполняться только в потоке сервера.");
        }
    }
}

// Команда для выполнения мягкого завершения работы потока сервера
public class SoftStopCommand : ICommand
{
    private readonly ServerThread serverThread;

    public SoftStopCommand(ServerThread serverThread)
    {
        this.serverThread = serverThread;
    }

    public void Execute()
    {
        if (Thread.CurrentThread == serverThread.GetThread())
        {
            serverThread.RequestSoftStop();
        }
        else
        {
            throw new InvalidOperationException("SoftStopCommand может выполняться только в потоке сервера.");
        }
    }
}

// Класс, который представляет поток сервера, отвечающий за обработку команд
public class ServerThread
{
    private Thread thread;
    private ConcurrentQueue<ICommand> commandQueue;
    private volatile bool isRunning;
    private volatile bool softStopRequested;
    private IScheduler scheduler;

    public ServerThread(IScheduler scheduler)
    {
        commandQueue = new ConcurrentQueue<ICommand>();
        this.scheduler = scheduler;
        thread = new Thread(Run) { IsBackground = true };
        isRunning = true;
    }

    // Запуск потока сервера
    public void Start() => thread.Start();

    // Остановка потока сервера
    public void Stop() { isRunning = false; thread.Join(); }

    // Добавление команды в очередь выполнения
    public void EnqueueCommand(ICommand command)
    {
        if (isRunning) { commandQueue.Enqueue(command); }
    }

    // Метод для выполнения мягкой остановки
    public void RequestSoftStop() { softStopRequested = true; }

    // Метод для выполнения жесткой остановки
    public void HardStop() { isRunning = false; }

    // Свойство, которое показывает, работает ли поток сервера
    public bool IsRunning => isRunning;

    // Метод для получения потока сервера
    public Thread GetThread() => thread;

    // Основной цикл потока сервера
    private void Run()
    {
        while (isRunning)
        {
            // Обработка команд из очереди
            if (commandQueue.TryDequeue(out ICommand command))
            {
                scheduler.Add(command);
            }

            // Выполнение команд из планировщика
            if (scheduler.HasCommand())
            {
                try
                {
                    var nextCommand = scheduler.Select();
                    nextCommand.Execute();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Исключение: {ex.Message}");
                }
            }
            else
            {
                Thread.Sleep(10); // Предотвращение излишней траты ресурсов процессора
            }

            // Проверка условия для мягкой остановки
            if (softStopRequested && commandQueue.IsEmpty && !scheduler.HasCommand())
            {
                isRunning = false;
            }
        }
    }
}


        // Создание планировщика
        IScheduler scheduler = new RoundRobinScheduler();

        // Создание потока сервера
        ServerThread serverThread = new ServerThread(scheduler);

        // Создание роутера сообщений
        MessageRouter messageRouter = new MessageRouter();

        // Создание обработчиков сообщений
        LongRunningCommand command1 = new LongRunningCommand(1);
        LongRunningCommand command2 = new LongRunningCommand(2);

        // Добавление обработчиков в роутер
        messageRouter.AddHandler(1, command1);
        messageRouter.AddHandler(2, command2);

        // Добавление роутера в очередь команд сервера
        serverThread.EnqueueCommand(messageRouter);

        // Запуск потока сервера
        serverThread.Start();

        // Отправка сообщений в роутер
        messageRouter.EnqueueMessage(new Message(1, "Сообщение для команды 1"));
        messageRouter.EnqueueMessage(new Message(2, "Сообщение для команды 2"));
        messageRouter.EnqueueMessage(new Message(3, "Сообщение для несуществующей команды"));
        // Ожидание завершения обработки сообщений
        Thread.Sleep(1000); // 1 секунда

        // Выполнение мягкой остановки потока
        serverThread.RequestSoftStop();

        // Ожидание завершения работы потока
        Thread.Sleep(1000);

        // Завершение работы программы
        Console.WriteLine("Сервер остановлен.");
        Console.ReadLine();
